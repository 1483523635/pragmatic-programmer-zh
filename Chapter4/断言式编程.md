# 断言式编程
<!-- 2020.03.31 -->

> 自责是奢侈的。当我们责怪自己时，我们觉得没有人有权利责怪我们。
>
> -- 奥斯卡·王尔德，《道林·格雷的照片》

似乎每个程序员在职业生涯的早期都必须记住一个咒语。它是计算的一个基本原则，是我们学习应用于需求、设计、代码、注释的核心信念，几乎是我们所做的一切。它就是：

    这永远不会发生

“此代码从现在起80年后将不再使用，所以两位数的日期就可以了。” “此应用程序永远不会在国外使用，那么为什么要使其国际化？” “计数不能为负。” “记录不会失败。”

我们不要练习这种自我欺骗，尤其是在编码时。

---
## 提示 39 用断言来防止不可能的事情
---

每当您发现自己在思考“但当然永远不会发生”时，请添加代码进行检查。 最简单的方法是使用断言。 在许多语言实现中，您会找到某种形式的 断言 来检查布尔条件。这些检查是无价的。 如果参数或结果永远不应为 null，则应明确检查它：

    assert（result != null）;

在 Java 实现中，您可以（并且应该）添加一个描述性字符串：

    assert result != null && result.size() > 0：“Empty result from XYZ”;

断言对于检查算法的操作也很有用。 也许您已经编写了一个聪明的排序算法，名为 my_sort。 检查它是否有效：

    books = my_sort(find("scifi"))
    assert(is_sorted?(books))

当然，传递给断言的条件不能有副作用（请参见后文）。还要记住，断言可能在构建或执行时关闭，永远不要将必须执行的代码放入断言中。

不要用断言代替真正的错误处理。断言检查不应该发生的事情：您不希望编写诸如

    puts("Enter 'Y' or 'N': ")
    ans = gets[0] # Grab first character of response
    assert((ch == 'Y') || (ch == 'N'))    # Very bad idea!”

仅仅因为大多数断言实现会在断言失败时终止进程，所以没有理由编写版本。如果需要释放资源，请捕获断言的异常或捕获出口，然后运行自己的错误处理程序。只要确保在那些垂死的毫秒内执行的代码不依赖于最初触发断言失败的信息。

---
### 断言和副作用

当我们为检测错误而添加的代码最终导致新的错误时，这是很尴尬的。如果评估条件有副作用，则断言可能会发生这种情况。例如，编写诸如

    while (iter.hasMoreElements()) {
      assert(iter.nextElement() != null);
      Object obj = iter.nextElement();
      // ....
    }

断言中的 .nextElement() 调用的副作用是将迭代器移过要获取的元素，因此循环将只处理集合中的一半元素。最好还是写

    while (iter.hasMoreElements()) {
      Object obj = iter.nextElement();
      assert(obj != null);
      // ....
    }

这个问题是一种 Heisenbug 调试，它改变了被调试系统的行为。一般来说，您应该使用语言构造，其中循环和迭代是由语言本身计算的，使用诸如 map、filter 或 apply 之类的东西来处理列表中的所有元素，而无需手动确定迭代的边界。

---

## 保持断言处于打开状态

关于断言存在一个普遍的误解。它是这样的：

    断言为代码增加了一些开销。因为他们检查了永远都不会发生的事情，所以它们只会被代码中的错误触发。一旦代码经过测试和发布，就不再需要它们，应该将其关闭以使代码运行更快。断言是一种调试工具。

这里有两个明显错误的假设。首先，他们认为测试可以找到所有错误。实际上，对于任何复杂的程序，您甚至都不可能测试将要通过代码的排列的很小一部分。其次，乐观主义者忘记了您的程序在危险的世界中运行。在测试期间，老鼠可能不会咬通讯电缆，玩游戏的人不会耗尽内存，日志文件也不会填满存储分区。当您的程序在生产环境中运行时，可能会发生这些事情。您的第一道防线是检查任何可能的错误，而第二道防线是使用断言来尝试检测您遗漏的错误。

将程序交付到生产环境时，关闭断言就像在没有网络的情况下越过高线，因为您曾经在实践中将其跨过。有巨大的价值，但很难获得人寿保险。

---
### 在生产中使用断言，赢得大笔资金

安迪（Andy）的一位前邻居领导了一家制造网络设备的小型创业公司。 他们成功的秘诀之一是决定在生产版本中保留断言。 这些声明经过精心设计，可以报告导致失败的所有相关数据，并通过美观的 UI 呈现给最终用户。 来自实际用户在实际条件下的这种反馈水平使开发人员可以填补漏洞并修复这些晦涩难懂的难以重现的错误，从而获得非常稳定的防弹软件。

这家不知名的小型公司拥有如此可靠的产品，很快就以数亿美元的价格被收购。

只是在说。

---

即使您确实有性能问题，也请仅关闭确实遇到问题的断言。 上面的排序示例可能是应用程序的关键部分，并且可能需要很快。 添加检查意味着再次传递数据，这可能是不可接受的。 使该特定检查为可选，其余部分留在原处。

### 练习 14（尽可能回答）

快速的现实检查。 哪些“不可能”的事情会发生？

- 少于28天的一个月
- 系统调用中的错误代码：无法访问当前目录
- 在C++ 中：a = 2; b = 3； 但是（a + b）不等于5
- 内角总和≠180°的三角形
- 一分钟没有60秒
- （a + 1）<= a

## 相关内容包括

- 话题 24 [_死程序不说谎_](./死程序不说谎.md)
- 话题 23 [_契约设计_](./契约设计.md)
- 话题 42 [_基于性能的测试_](../Chapter7/基于性能的测试.md)
- 话题 43 [_在某处保持安全_](../Chapter7/在某处保持安全.md)
