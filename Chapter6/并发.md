# 并发
<!-- 2020.04.09 -->

就像我们都在同一页上一样，让我们从一些定义开始：

_并发性_ 是指两段或多段代码的执行好像它们同时运行一样。_并行_ 是指它们确实同时运行。

要获得并发性，需要在运行代码时可以在代码的不同部分之间切换执行的环境中运行代码。这通常使用诸如光纤、线程和进程之类的东西来实现。

要实现并行，您需要能够同时执行两件事情的硬件。这可能是一个 CPU 中的多个核心，一台计算机中的多个 CPU，或者连接在一起的多台计算机。

## 一切都是并发
几乎不可能在一个大小合适、没有并发方面的系统中编写代码。它们可能是明确的，也可能埋在图书馆里。如果你想让你的应用程序能够处理现实世界中的异步事务，并发是一个要求：用户交互，数据获取，调用外部服务，所有这些都是同时进行的。如果你强迫这个进程是串行的，一件事发生，然后下一件事发生，依此类推，你的系统会感觉很迟钝，你可能没有充分利用它运行的硬件的能力。
在本章中，我们将讨论并发和并行：

开发人员经常谈论代码块之间的耦合。他们指的是依赖关系，以及这些依赖关系如何使事情难以改变。但还有另一种形式的耦合。当您的代码将一个序列强加给不需要解决手头问题的东西时，就会发生时间耦合。你相信“滴答”在“滴答”之前吗？如果你想保持灵活就不要了。您的代码是否按顺序访问三个后端服务？如果你想留住你的用户就不要了。在话题 33，[_断开时间耦合_](./断开时间耦合.md) 中，我们将研究识别这种时间耦合的方法。

为什么编写并发和并行代码这么困难？一个原因是我们学会了使用顺序系统编程，我们的语言具有顺序使用时相对安全的特性，但一旦两件事同时发生，就成为一种负担。这里最大的罪魁祸首之一是共享状态。这不仅仅意味着全局变量：只要两个或多个代码块包含对同一可变数据块的引用，就可以共享状态。话题 34，[_共享状态是不正确的状态_](./共享状态是不正确的状态.md) 这一节描述了许多解决方法，但最终它们都容易出错。

如果这让你感到悲伤，绝望！有更好的方法来构造并发应用程序。其中之一是使用 actor 模型 ，其中独立的进程（不共享数据）使用定义的简单语义通过 channel 进行通信。我们在话题 35 [_Actors和进程_](./actors和进程.md) 中讨论了这种方法的理论和实践。

最后，我们来看看话题36，[_黑板_](./黑板.md)。这些系统就像是对象存储和智能发布/订阅代理的组合。在他们最初的状态下，他们从未真正起飞。但今天，我们看到越来越多的中间件层实现了黑板式的语义。正确地使用，这些类型的系统提供了大量的解耦。

并发和并行代码过去是很奇特的。现在它是必需的。
