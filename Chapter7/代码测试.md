# 代码测试
<!-- 2020.04.19 -->
这本书的第一版是在更原始的时代写的，当时大多数开发者都不写测试----他们认为，反正2000年的时候，世界就要结束了，何必费劲呢。

在那本书中，我们有一节是关于如何构建易于测试的代码。这是一种偷偷摸摸地说服开发者真正写测试的方法。

这是个比较开明的时代。如果还有开发人员不写测试，至少他们知道自己应该写测试。

但还是有一个问题。当我们问开发者为什么要写测试时，他们看我们的眼神，就好像我们只是问他们是否还在用打卡的方式进行编码，他们会说 "确保代码能正常工作"，并在结尾处加上一个不为人知的 "假人"。而我们认为这是不对的。

那么，我们认为测试的重要性是什么？以及我们认为你应该如何去做？

让我们先从这句话开始说起。

---
## 提示 66 测试不是为了找 BUG
---

我们相信，测试的主要好处是在你思考和编写测试的时候，而不是在你运行测试的时候。

## 关于测试的思考
这是一个星期一的早晨，你坐下来开始写一些新的代码。你必须写一些东西来查询数据库，返回一个每周在你的 "世界上最有趣的洗碗视频 "网站上观看 10 个以上视频的人的列表。

你启动你的编辑器，从编写执行查询的函数开始。

```elixir
def return_avid_viewers do
  # ... hmmm ...
end
```

停！你怎么知道你要做的事是好事？

答案是，你无法知道。谁都不可能知道。但思考测试可以让它更有可能。下面是这样做的方法。

首先想象一下，你已经写完了函数，现在要对它进行测试。你会怎么做呢？嗯，你会想使用一些测试数据，这可能意味着你想在你控制的数据库中工作。现在，有些框架可以为你处理这个问题，在测试数据库中运行测试，但在我们的例子中，这意味着我们应该将数据库实例传递到我们的函数中，而不是使用一些全局的数据库实例，因为这样我们可以在测试时改变它。

```elixir
def return_avid_users(db) do
```

然后我们要考虑如何填充这些测试数据。这个需求想要 "每周观看10 个以上视频的人的列表" 所以我们在数据库模式中寻找可能有帮助的字段。我们在 who-watched-what 表中找到了两个可能的字段：open_video 和 completed_video。为了写出我们的测试数据，我们需要知道该用哪个字段。但是我们不知道这个需求是什么意思，我们的业务联系也在外部。那我们就在字段的名称中传递一个假的。这意味着我们可以测试一下我们所拥有的东西，以后有可能再去更改它。

```elixir
def return_avid_users(db, qualifying_field_name) do
```

我们开始思考我们的测试，不用写一行代码，就已经有了两个发现，并利用它们来改变我们的 API 方法。

## 测试驱动编码
在前面的例子中，对测试的思考使我们减少了代码中的耦合（通过传递数据库连接，而不是使用全局连接），并增加了灵活性（将我们测试的字段名称作为参数传递）。为我们的方法编写测试的思考使我们从外部看问题，就好像我们是代码的客户，而不是代码的作者。

---
## 提示 67 测试是你代码的第一个用户
---

我们认为这可能是测试提供的最大好处：测试是指导你编码的重要反馈。一个与其他代码紧密耦合的函数或方法是很难测试的，因为你必须在运行你方法之前设置好所有的环境。所以让你的东西可测试，也会降低它的耦合性。

而在测试东西之前，你必须先了解它。这听起来很傻，但在现实中，我们都是基于对自己所要做的事情的模糊理解而发起了一段代码。我们向自己保证，我们会边走边想办法。哦，以后我们也会添加所有支持边界条件的代码。哦，还有错误处理。而代码最终要比它应该的长度长五倍，因为它充满了条件逻辑和特殊情况。但把测试的光照在那段代码上，事情就会变得更清晰了。如果你在开始编写代码之前就考虑测试边界条件，以及这将如何工作，你很可能会在逻辑中找到简化函数的规律。如果你想好了你需要测试的错误条件，你就会相应地构造你的函数。

## 测试驱动的开发
有一个学派说，既然在前面想好了测试的种种好处，为什么不在前面也去写测试呢？他们实践的东西叫做测试驱动开发或 TDD。你也会看到这种叫做 "测试优先开发" [62] 。

TDD的基本周期是。

1. 决定你要添加的一小块功能。

2. 编写一个测试，一旦实现了这个功能就会通过。

3. 运行你所有的测试，并验证唯一失败的就是你刚才写的那个测试。

4. 写出最少的代码来让测试通过，并验证测试现在运行得很干净。

5. 重构你的代码：看看是否有办法改进你刚才写的东西（测试或函数）。确保测试完成后仍然能通过。

我们的想法是，这个周期应该很短：几分钟的时间，这样你就可以不断地写测试，然后让它们发挥作用。
我们看到 TDD 对于刚开始做测试的人来说有很大的好处。如果你遵循 TDD 工作流，你将保证你的代码总是有测试。而这意味着你会一直在思考你的测试。

然而，我们也看到人们成为 TDD 的奴隶。这表现在很多方面。

- 他们花了大量的时间来确保自己的测试覆盖率始终是100%。

- 他们有大量的冗余测试。例如，在第一次写一个类之前，很多 TDD 的坚持者会先写一个失败的测试，简单地引用类的名称，然后写一个失败的测试。它失败了，然后他们写一个空的类定义，它就通过了。但是现在你的测试完全没有任何作用；下一次写的测试也会引用这个类，所以第一次写的测试就没有必要了。如果以后类的名字变了，需要修改的东西就更多了。而这只是一个琐碎的例子。

- 他们的设计倾向于从底层开始，然后往上走。(见自下而上 VS 自上而下 VS 你应该做的事情）。

---
### 自下而上 VS 自上而下 VS 你应该做的事情

早在计算机还很年轻的时候，有两种设计流派：自上而下和自下而上。自上而下的人说，你应该从你要解决的整体问题开始，把它分解成一小部分。然后再把每个问题分解成更小的部分，以此类推，直到最后你有了足够小的部分，可以用代码来表达。

自下而上的人在构建代码的时候，就像建造房子一样。他们从最底层开始，产生一层代码，给他们提供一些抽象的、更接近他们要解决的问题。然后，他们又增加了另一层，再加上更高层次的抽象。他们一直坚持下去，直到最后一层是解决了问题的抽象。"把它变成这样..........."

这两派实际上都不可行，因为这两派都忽略了软件开发中最重要的一个方面：我们在开始时并不知道自己在做什么。自上而下的人假设他们可以在前面表达出整个需求：他们不能。自下而上的人假设他们可以建立一个抽象的列表，最终会把他们带到一个单一的顶层解决方案，但是当他们不知道自己的方向在哪里时，如何决定层的功能呢？

## 提示 68 构建端到端，而不是自上而下或自下而上

我们坚信，构建软件的唯一方法就是循序渐进。构建端到端功能的小块，边做边学。在你继续完善代码的过程中应用这些学习，让客户参与到每一步，并让他们指导整个过程。

---

通过各种手段练习 TDD。但是，如果你这样做了，不要忘记每隔一段时间就停下来看看大局。很容易被绿色的 "测试通过 "的消息所诱惑，写了很多代码，但实际上并不能让你更接近于解决方案。

## 回到代码
基于组件的开发一直以来都是软件开发的一个崇高目标。其想法是，通用的软件组件应该像普通集成电路（IC）一样容易获得和组合。但只有当你所使用的元件是已知的可靠的，并且有共同的电压、互连标准、时序等等，这才行得通。

芯片的设计是要经过测试的--不只是在工厂里，不只是在安装的时候，在现场部署的时候也要经过测试。更复杂的芯片和系统可能有一个完整的内置自测试(BIST)功能，可以在内部运行一些基础级的诊断，或者是测试访问机制(TAM)，提供一个测试线束，允许外部环境提供刺激并收集芯片的响应。

我们在软件上也可以做同样的事情。就像我们的硬件同事一样，我们需要从一开始就把可测试性建立在软件中，并在试图将每一个部件连接在一起之前，对其进行彻底的测试。

## 单元测试
硬件的芯片级测试大致相当于软件中的单元测试--对每个模块单独进行测试，以验证其行为。一旦我们在可控的（甚至是伪造的）条件下进行了测试，我们就能更好地感受到一个模块在大的世界中的反应。

软件的单元测试是锻炼模块的代码。通常情况下，单元测试会建立某种人工环境，然后在被测模块中调用例程。然后，它对返回的结果进行检查，可以是对照已知值，也可以是对照以前运行相同测试的结果（回归测试）。

稍后，当我们将 "软件IC"组装成一个完整的系统时，我们就可以确信各个部分都能按预期工作，然后我们就可以使用同样的单元测试设施来测试整个系统。我们在 [_无情测试和持续测试_](../Chapter9/实用入门套件.md) 中谈到了这种大规模的系统检查。

然而，在走到这一步之前，我们需要决定在单元级测试什么。从历史上看，程序员会把一些随机的数据扔到代码中，看一下打印语句，然后称其为测试。我们可以做得更好。

## 针对契约的测试
我们喜欢把单元测试看成是针对契约测试（见 话题 23, [_契约设计_](../Chapter4/契约设计.md) ）。我们要编写测试用例，确保给定的单元遵守合同。这将告诉我们两件事：一是代码是否符合合同，二是合同是否意味着我们认为的意思。我们希望在广泛的测试用例和边界条件下，测试模块是否提供了它所承诺的功能。

这在实践中意味着什么？让我们从一个简单的数字例子开始：一个平方根例程。它的文档化的契约很简单。

```js
pre-conditions:
    argument >= 0;
post-conditions:
    ((result * result) - argument).abs <= epsilon * argument;
```

这告诉我们要测试什么。

- 传入一个负参数，确保它被拒绝。

- 传入一个 0 的参数，确保它被接受（这是边界值）。

- 传入零与最大可表达参数之间的值，并验证结果的平方与原始参数的差值小于参数的某一小部分（epsilon）。

有了这个契约，假设我们的例程自己做了前后条件检查，我们就可以写一个基本的测试脚本来测试平方根函数。

然后我们可以调用这个例程来测试我们的平方根函数：
```python
assertWithinEpsilon(my_sqrt(0), 0)
assertWithinEpsilon(my_sqrt(2.0), 1.4142135614)
assertWithinEpsilon(my_sqrt(64.0), 8.0)
assertWithinEpsilon(my_sqrt(1.0e7), 3162.3776602)
assertWithinEpsilon fn => my_sqrt(-4.0) end
```

这是一个相当简单的测试；在现实世界中，任何一个不重要的模块都有可能依赖于其他一些模块，那么我们该如何去测试这个组合呢？

假设我们有一个使用 DataFeed 和 LinearRegression 的模块 A。按照顺序，我们将测试。

1. DataFeed 的合同，完整的

2. LinearRegression 的合同，完整的

3. A 的合同，其依附于其他合同，但不直接暴露出其他合同的内容

这种测试方式需要你先对模块的子组件进行测试。一旦子组件被验证了，就可以对模块本身进行测试。

如果 DataFeed 和 LinearRegression 的测试通过了，但 A 的测试失败了，那么我们就可以很确定问题出在 A中，或者说问题出在 A 对其中一个子组件的使用上。这种技术是减少调试工作量的好方法：我们可以快速地集中在模块 A 中可能的问题源头，而不需要浪费时间重新检查它的子组件。

为什么我们要这么麻烦？最重要的是，我们要避免产生一个 "定时炸弹"--在项目中不被注意到的情况下，在项目后期的某个尴尬时刻爆炸。通过强调对合同的测试，我们可以尽量避免那些下游的灾难。

## 设计到测试
---
### 专项测试
不要和 "奇怪的黑客" 混淆，在编码和调试时的临时测试中，我们最终可能会在即时创建一些特殊的测试。这些可能是像 console.log() 一样简单，也可能是在调试器、IDE 环境或 REPL 中交互输入的一段代码。

在调试结束后，你需要将这个临时测试正式化。如果代码坏了一次，很可能会再次坏掉。不要把你创建的测试扔掉，要把它添加到现有的单元测试库中。

---

## 建立一个测试窗口
即使是最好的测试，也不可能找到所有的 BUG；生产环境中潮湿、温暖的条件下，似乎有一些东西能把它们带出来。
这就意味着，一旦软件部署完毕，你往往需要在实际数据流经其脉络的情况下对其进行测试。与电路板或芯片不同，我们在软件中没有测试引脚，但我们可以提供模块内部状态的各种视图，而不需要使用调试器（这在生产应用中可能不方便或不可能）。

包含跟踪消息的日志文件就是这样一种机制。日志消息应该是有规律的、一致的格式；你可能希望自动解析它们，以推断出程序所采取的处理时间或逻辑路径。格式不正确或不一致的诊断程序就是这么多的 "喷出"--它们很难阅读，而且不切实际地进行解析。

另一种进入运行中的代码的机制是 "热键" 序列或神奇的 URL。当这个特殊的组合键被按下，或 URL 被访问时，就会弹出一个诊断控制窗口，显示状态信息等。这是你通常不会透露给最终用户的东西，但对于帮助台来说，它可以非常方便。

一般来说，你可以使用功能开关来为特定的用户或用户类别启用额外的诊断功能。

## 测试文化
你所编写的所有软件都要经过测试，如果不是由你和你的团队来测试，那么最终的用户也会对其进行测试，所以你最好计划好对其进行彻底的测试。稍作预想，就可以大大减少维护成本和帮助台的呼叫。

你真的只有几个选择。

- 首先进行测试

- 测试期间

- 永不测试

Test First，包括测试驱动设计，可能是大多数情况下你最好的选择，因为它可以确保测试的发生。但有时这并不是那么方便或有用，所以在编码过程中测试可以是一个很好的退路，在这里你写一些代码，摆弄它，为它写测试，然后转到下一个位子。最糟糕的选择通常被称为 "Test Later"，但你在跟谁开玩笑呢？"Test Later" 真的是 "Test Never" 的意思。

一个测试文化意味着所有的测试都能通过。忽略了一堆 "总是失败" 的测试，就容易忽略所有的测试，恶性循环就开始了（见话题 3，[_软件熵_](../Chapter1/软件熵.md) ）。

对待测试代码要像对待任何生产代码一样小心翼翼。保持它的解耦、干净和健壮。不要依赖不可靠的东西（参见 话题 38, [_巧合编程_](./巧合编程.md) ），比如 GUI 系统中小部件的绝对位置，或者服务器日志中的确切时间戳，或者错误信息的确切措辞。对这些东西进行测试会导致测试的结果是脆弱的。

---
## 提示 70 测试你的软件，否则你的用户会帮你测试
---

毫无疑问，测试是编程的一部分。它不是留给其他部门或员工的事情。

测试、设计、编码，都是编程的一部分。

---
### 告解
我（Dave）曾告诉人们，我不再写测试了。部分原因是为了动摇那些把测试变成了宗教的人的信心。部分原因是我说这句话是真的。

我已经写了 45 年的代码，写了 30 多年的自动化测试。对测试的思考是我对待编码的方式中内置的。这让我感觉很舒服。而我的个性坚持认为，当某件事情开始觉得舒服的时候，我应该转到别的事情上。

在这种情况下，我决定停止写测试几个月，看看它对我的代码有什么影响。令我惊讶的是，答案是"不多"。所以我花了一些时间来研究原因。

我相信答案是（对我来说）测试的大部分好处来自于思考测试及其对代码的影响。而且，在做了这么久之后，我可以在不写测试的情况下进行这种思考。我的代码仍然是可以测试的，只是没有经过测试。

但这忽略了一个事实，即测试也是与其他开发者交流的一种方式，所以我现在确实在与他人共享的代码上写了测试。

Andy 说，我不应该包括这个侧边栏。他担心这会引诱没有经验的开发者不做测试。这是我的折中方案。

你应该写测试吗？是的，应该。但是，在你做了 30 年之后，你可以自由尝试一下，看看对你的好处在哪里。

---

## 相关内容包括
- 话题 27 [_别开过头了_](../Chapter4/别开过头了.md)
- 话题 50 [_实用入门套件_](../Chapter9/实用入门套件.md)
