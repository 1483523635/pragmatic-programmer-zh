# Debug
<!-- 2020.03.25 -->

> _这是一件痛苦的事_
> _看着自己的麻烦并且知道_
> _没有人做到，包括你自己_
>
> -- _Sophocles，阿贾克斯_

自十四世纪以来，错误（bug）一词就一直被用来描述“恐怖的对象”。海军少将 Grace Hopper 博士是 COBOL 的发明者，他因观察到了第一个计算机错误-从字面上看，它是早期计算机系统中继器中捕获的飞蛾。当被问及为什么机器不按预期运行时，一名技术人员报告说“系统中存在错误”，并忠实地将其翅膀和所有部件粘贴到日志中。

遗憾的是，尽管系统不是飞行类，但仍然存在错误。但是，十四世纪的意义 - 一个鬼怪 - 也许现在比那时更适用。从错误的需求到编码错误，软件缺陷以多种方式表现出来。不幸的是，现代计算机系统仍然仅限于执行您要求它们执行的操作，而不一定要执行您希望它们执行的操作。

没有人会编写完美的软件，因此调试将占用您一天的大部分时间。让我们看一下调试中涉及的一些问题以及发现难以捉摸的错误的一些一般策略。

## 调试心理学

对于许多开发人员来说，调试是一个敏感、感性的话题。与其把它当作一个有待解决的难题来攻击，你可能会遇到否认、指手画脚、蹩脚的借口，或者只是单纯的冷漠。

接受这样一个事实，调试只是解决问题，并攻击它本身。

找到别人的 bug 后，你可以花时间和精力去责怪制造它的肮脏的罪魁祸首。在一些工作场所，这是文化的一部分，可能是一种宣泄。然而，在技术领域，你要集中精力解决问题，而不是指责。

---
## 提示 29 解决问题，而不是责怪
---

该错误是您的错还是其他人的错并不重要。 仍然是你的问题。

## 调试心态

在开始调试之前，务必要采用正确的心态。 您需要关闭每天用于保护自我的许多防御措施，调整可能承受的任何项目压力，并使自己感到舒适。 首先，请记住调试的第一条规则：

---
## 提示 30 稳住别慌
---

恐慌很容易发生，尤其是在您面临最后期限的情况下，或者当您试图找出错误的原因时，有一个紧张的老板或客户喘口气的时候。 但是，退后一步，并认真考虑可能导致您认为是错误的症状的原因非常重要。

如果您对目睹错误或看到错误报告的第一反应是“不可能的”，那显然是错误的。 不要在开始于“但那不可能发生”的思路上浪费单个神经元，因为很明显它可以而且已经存在。

调试时要小心近视。抵制只解决您所看到的症状的冲动：实际故障很可能是从您所观察的内容中删除了几个步骤，并且可能涉及许多其他相关事项。始终尝试发现问题的根本原因，而不仅仅是问题的特殊外观。

## 从哪儿开始

在开始查看该错误之前，请确保您正在使用干净构建的代码-没有警告。我们通常将编译器警告级别设置为尽可能高。浪费时间去寻找计算机可以为您找到的问题是没有道理的！我们需要集中精力解决眼前的难题。

尝试解决任何问题时，您需要收集所有相关数据。不幸的是，错误报告并不是一门精确的科学。很容易被巧合所误导，您也不能浪费时间调试巧合。您首先需要在观察中保持准确。

通过第三方报告时，错误报告的准确性会进一步降低-您可能实际上需要观察实际报告错误的用户，以获取足够的详细程度。

安迪曾经研究过一个大型的图形应用程序。在即将发布的时候，测试人员报告说，每次他们用特定的画笔绘制笔划时，应用程序都会崩溃。负责的程序员辩称没有什么问题；他试过用它画画，效果很好。这段对话持续了好几天，情绪迅速高涨。

最后，我们把他们聚集在同一个房间里。测试人员选择了画笔工具并绘制了从右上角到左下角的笔划。应用程序崩溃了。“哦，”程序员用一种微弱的声音说，然后他不好意思地承认，他只做了从左下到右上的测试笔划，没有暴露出错误。

这个故事有两点：

- 为了收集比最初给出的更多的数据，您可能需要访问报告错误的用户。

- 人工测试（例如程序员从下到上的单笔笔划）对应用程序的锻炼不够。您必须残酷地测试边界条件和实际的最终用户使用模式。

  你需要系统地做这件事（见 无情和持续的测试 ）。

## 调试策略

一旦您知道发生了什么，就该找出程序认为正在发生什么的时候了。

### Bug 复现

不，我们的漏洞并没有真的成倍增长（尽管其中一些可能已经足够大，可以合法地做到这一点）。我们说的是另一种复现。

开始修复错误的最好方法是使其可复现。毕竟，如果你不能复现它，你怎么知道它是否被修复好？

但是，我们需要的不仅仅是一个可以通过一系列步骤复现的 bug；我们需要一个可以通过一个命令复现的 bug。如果你必须经过15个步骤才能达到错误出现的程度，那么修复错误就要困难得多。

因此，以下是调试的最重要规则：

---
## 提示 31 代码修复前测试失败
---

有时，通过强迫自己隔离显示该错误的情况，您甚至可以深入了解如何解决该错误。 编写测试的行为为解决方案提供了依据。

### 陌生土地上的编码员

关于隔离bug的所有讨论都很好，当面对50,000行代码和滴答作响的时钟时，糟糕的编码器怎么办？

首先，看问题。 这是崩溃吗？ 当我们讲授与编程有关的课程时，总是令人惊讶的是，有多少开发人员看到异常以红色弹出，并在代码中带有即时选项卡。

---
## 提示 32 阅读该死的错误消息
---

### 糟糕的结果

如果这不是程序崩溃。只是结果不好怎么办？使用调试器进入，然后使用失败的测试来触发问题。

首先，请确保您还在调试器中看到了错误的值。我们俩都浪费了很多时间来试图查找错误，只是发现这种特定的代码运行良好。
有时问题很明显：interest_rate 为 4.5，应为 0.045。更多时候，您必须更深入地研究，以找出为什么值首先是错误的。确保您知道如何上下移动调用堆栈并检查本地堆栈环境。

我们发现通常可以将笔和纸放在附近，这样我们就可以记笔记了。特别是，我们经常碰到一个线索并追逐它，却发现它没有成功。如果我们在开始追赶时没有记下自己的位置，则可能会浪费很多时间回到那里。

有时您正在查看似乎一直滚动的堆栈跟踪。在这种情况下，通常使用二进制印章比检查每个堆栈帧更快地找到问题。但是在讨论之前，让我们看一下另外两个常见的错误场景。

### 对输入值的敏感性

你遇到过。 您的程序可以很好地处理所有测试数据，并且可以在生产的第一周中幸存下来。 然后在送入特定数据集时突然崩溃。
您可以尝试查看它崩溃的地方并向后工作。 但是有时候从数据开始比较容易。 获取数据集的副本，并通过应用程序的本地运行副本将其提供，以确保它仍然崩溃。 然后将数据二进制二进制化，直到您准确隔离导致崩溃的输入值为止。

### 各个版本之间的回归

您拥有一支优秀的团队，并且将软件投入生产。 在某个时候，一个错误会在一周前可以正常工作的代码中弹出。 如果您能确定引入它的特定更改，那岂不是很好吗？ 你猜怎么了？ 二进制印章时间。

## 二进制印章

每个计算机专业的本科生都被迫编写二进制印章（有时称为二进制搜索）。这个想法很简单。您正在寻找排序数组中的特定值。您可以依次查看每个值，但最终会平均查看大约一半的条目，直到找到所需的值，或者找到的值大于该值，这意味着该值不在数组。

但是使用 _分而治之_ 的方法更快。在数组中间选择一个值。如果这是您要寻找的那个，请停止。否则，您可以将阵列切成两半。如果找到的值大于目标值，则说明它必须位于数组的前半部分，否则位于后半部分。在适当的子数组中重复该过程，您将很快获得结果。（正如我们在谈论 Big-O 表示法 时所看到的那样，线性搜索为 O(n) ，二进制印章为O(log n) 。

因此，二进制印章是解决任何体面大小问题的方法。让我们看看如何将其应用于调试。

当您面对大量的堆栈跟踪并试图准确找出哪个函数破坏了错误的值时，您可以通过在中间的某个位置选择一个堆栈框架并查看错误是否明显来进行切碎。如果是这样，那么您就知道要集中在前面的帧上，否则问题就出在后面的帧上。即使您的堆栈跟踪中有64帧，这种方法最多也可以在尝试6次后为您提供答案。

如果您发现某些数据集中出现的错误，则可以执行相同的操作。将集合分成两部分，如果一部分通过应用程序，另一部分则出现问题。继续划分数据，直到获得最小的显示问题的值集为止。

如果您的团队在一组发行版中引入了一个错误，则可以使用相同类型的技术。创建一个导致当前版本失败的测试。然后选择从现在到最后一个已知的工作版本之间的发布。再次运行测试，然后决定如何缩小搜索范围。能够执行此操作只是在项目中拥有良好的版本控制的众多好处中的一部分。的确，许多版本控制系统会更进一步，并且会自动执行该过程，并根据测试结果为您选择发行版本。

## 记录和/或跟踪

调试器现在通常关注程序的状态。有时你需要更多的时间来观察程序或数据结构的状态。看到堆栈跟踪只能告诉你是怎么直接到这里的。它通常不能告诉你在这个调用链之前你在做什么，特别是在基于事件的系统中。

_跟踪语句_ 是打印到屏幕或文件中的一些诊断消息，例如“got here” 和 “value of x=2”。与IDE风格的调试器相比，这是一种原始技术，但它在诊断调试器不能诊断的几类错误时特别有效。跟踪在任何情况下都是非常宝贵的时间本身是一个因素的系统：并发进程、实时系统和基于事件的应用程序。

您可以使用跟踪语句来深入代码。 也就是说，您可以在调用树下降时添加跟踪语句。

跟踪消息应采用常规、一致的格式，因为您可能希望自动解析它们。例如，如果需要跟踪资源泄漏（例如文件打开/关闭不平衡），可以跟踪日志文件中的每个打开和关闭。通过使用文本处理工具或 shell 命令处理日志文件=您可以很容易地确定违规打开的位置。

## 橡皮鸭

找到问题原因的一种非常简单但特别有用的方法是简单地向其他人解释。另一个人应该看着你的屏幕，不停地点头（就像一只在浴缸里上下摆动的橡皮鸭）。他们不需要说一个字；一步一步地解释代码应该做什么，这种简单的行为通常会导致问题自己从屏幕上跳出来。

这听起来很简单，但是在向另一个人解释问题时，您必须明确地说明在您自己浏览代码时可能认为理所当然的事情。通过口头表达这些假设，你可能会突然对问题有新的见解。如果你没有人，橡胶鸭，泰迪熊，盆栽植物就可以了。

## 排除法

在大多数项目中，您要调试的代码可能是您和其他项目团队里的人编写的，或者第三方产品（数据库，连接性，Web框架，专用通信或算法等）和平台上编写的应用程序代码的混合体环境（操作系统，系统库和编译器）。

操作系统，编译器或第三方产品中可能存在错误，但这不是您首先想到的。该错误很可能存在于正在开发的应用程序代码中。通常，假定应用程序代码错误地调用了一个库比假定库本身已损坏，这更有利可图。即使问题确实出在第三方，您仍必须在提交错误报告之前消除代码。

我们在一个项目中工作，高级工程师确信该项目在 Unix 系统上中断了 select 系统调用。没有任何说服力或逻辑可以改变他的想法（盒子里的所有其他网络应用程序都运行良好这一事实是无关紧要的）。他花了数周的时间编写解决方法，出于某种奇怪的原因，该解决方法似乎无法解决问题。当最终被迫坐下来阅读 select 文档时，他发现了问题并在几分钟内纠正了问题。现在，只要我们中的一个人开始将系统归咎于可能是我们自己的错误，我们就会在此使用“选择已损坏”这个词来温和地提醒您。

---
## 提示 33 "select" 没有损坏
---

请记住，如果您看到蹄印，请思考马而不是斑马。 操作系统可能没有损坏。 select 可能是好的。

如果您“仅更改了一件事情”而系统停止运行，则不管看起来多么牵强，该一件事情都可能直接或间接地引起责任。 有时，发生变化的事情超出了您的控制范围：新版本的OS，编译器，数据库或其他第三方软件可能会对以前正确的代码造成严重破坏。 可能会出现新的错误。 解决了您需要解决的错误，从而破坏了解决方法。 API更改，功能更改； 简而言之，这是一个全新的球类游戏，您必须在这些新条件下重新测试系统。 因此，在考虑升级时，请密切注意时间表。 您可能要等到下一个版本发布。

## 惊喜元素

当您发现自己对错误感到惊讶时（甚至在我们听不到您的呼吸中喃喃自语“那不可能”），您必须重新评估您所珍视的真理。 在这种折扣计算算法中（您知道的那种算法是防弹的，不可能是导致该错误的原因），您是否测试了所有边界条件？ 您使用了多年的其他代码-可能仍然没有bug。 这可以吗？

当然可以。 当出现问题时，您感到惊讶的程度与您对正在运行的代码的信任和信任程度成正比。 因此，当您面对“令人惊讶的”失败时，您必须意识到自己的一个或多个假设是错误的。 不要掩盖该错误所涉及的例程或代码段，因为您“知道”它的工作原理。 证明给我看。 在此情况下，使用这些数据和这些边界条件进行证明。

---
## 提示 34 不要假设它-证明它
---

当您遇到一个令人惊讶的错误时，不仅要修复它，还需要确定为什么未尽早发现此故障。考虑是否需要修改单元或其他测试，以使他们能够抓住它。

此外，如果该错误是由于不良数据在引起崩溃之前已通过几个级别传播的结果，请查看这些例程中更好的参数检查是否可以更早地对其进行隔离（请参见此处及此处有关早期崩溃和断言的讨论，分别。）

当您使用它时，代码中是否还有其他地方可能容易受此相同错误的影响？现在是时候找到并修复它们了。确保无论发生什么，您都将知道是否再次发生。

如果修复此错误花了很长时间，请问问自己为什么。您是否可以采取任何措施使下次更轻松地修复此错误？也许您可以建立更好的测试挂钩，或编写日志文件分析器。

最后，如果错误是某人错误假设的结果，请与整个团队讨论该问题：如果一个人误解了，那么很多人可能会这样做。

完成所有这些操作，希望您下次不会感到惊讶。

## 调试检查表

- 被报告的问题是潜在错误的直接结果，还是仅仅是症状？

- 该错误确实在您使用的框架中吗？ 在操作系统中吗？ 还是在您的代码中？

- 如果您向同事详细解释了这个问题，您会怎么说？

- 如果可疑代码通过了其单元测试，则测试是否足够完成？ 如果使用此数据运行测试会怎样？

- 导致此错误的条件是否存在于系统中的其他任何地方？ 幼虫还在等待孵化吗？

## 相关内容包括

- 话题 24 [_死程序不说谎_](../Chapter4/死程序不说谎.md)

## 挑战

- 调试就是足够的挑战
