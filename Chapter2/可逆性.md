# 可逆性
<!-- 2020.03.07 -->

> 如果这是您唯一的想法，没有什么比这更危险了。
> --- _埃米尔·奥古斯特·沙蒂埃（阿兰），《宗教提案》，1938年_

工程师更喜欢简单，单一的解决方案。 数学测试可以使您满怀信心地宣称 x = 2 比关于法国大革命的各种模糊热情原因的论文要舒适得多。 管理层倾向于与工程师达成一致：单个简单的答案非常适合电子表格和项目计划。

如果只有现实世界能够合作！ 不幸的是，虽然 x 今天是 2，但可能明天需要它是 5，下周可能是 3。 没有什么是永远的 --- 如果您严重依赖某个事实，则几乎可以保证它会改变。

总是有不止一种方法来实现某些功能，而且通常有不止一家供应商可以提供第三方产品。 如果您进入的项目受到近视概念（只有一种方法）的束缚，那么您可能会感到不快。 随着未来的发展，许多项目团队被迫睁大了眼睛：

    “但是您说过我们要使用数据库 XYZ！ 我们已经完成了项目编码的 85％，我们现在不能更改！” 程序员抗议。 “抱歉，但是我们公司决定改为对所有项目使用数据库 PDQ 进行标准化。 所有项目。这是我无法控制的。我们只需要重新编码。你们所有人都将在周末工作，直到另行通知”

更改不必那么严厉，甚至不必那么紧迫。但随着时间的推移，你的项目进展，你可能会发现自己陷入了一个站不住脚的位置。在每一个关键的决策中，项目团队都致力于一个更小的目标，一个拥有更少选择现实的窄版本。

一旦做出许多关键决定，目标就会变得很小，以至于它移动，风向改变，东京的蝴蝶拍打翅膀，你都会错过。[18] 你可能会错过很多。

问题在于关键的决定不容易逆转。

一旦你决定使用该供应商的数据库，该体系结构模式或某个部署模型，您便会采取行动，除非付出很大的代价，否则无法撤消。

## 可逆性

本书中的许多话题都旨在生产灵活，适应性强的软件。 通过坚持他们的推荐，尤其是 [DRY 原则](./重复的恶魔.md)，[解耦](../Chapter5/解耦.md) 和使用[外部配置](../Chapter5/配置.md)，我们不必做出许多关键的，不可逆的决定。 这是一件好事，因为我们并不总是在第一次就做出最佳决定。 我们致力于某种技术，只是发现我们无法雇用足够的具有必要技能的人员。 我们会在竞争对手将其收购之前锁定某些第三方供应商。 需求，用户和硬件变更的速度快于我们开发软件的速度。

假设您在项目早期决定使用供应商 A 的关系数据库。后来，在性能测试期间，您发现该数据库太慢了，但是供应商B的文档数据库却很快。 对于大多数常规项目，您会很不幸。 在大多数情况下，在整个代码中都纠缠了对第三方产品的调用。 但是，如果您真的将数据库的概念抽象出来（仅提供持久性即服务的程度），这样你就有了在中途换马的灵活性。

同样，假设该项目从一个基于浏览器的应用程序开始，但是游戏，市场决定他们真正想要的是一个移动应用程序。 那对你有多难？ 在理想的情况下，它不会对您造成太大的影响，至少在服务器方面不会造成太大影响。 您将剥离一些 HTML 呈现，并用 API 替换它。

错误在于假设任何决定都是一成不变的，并且没有为可能发生的突发事件做准备。 与其将决策刻在石头上，不如将它们想象成是写在沙滩上的沙子上。 随时可能发生大浪，将其消灭。

---
## 提示 18 没有最终决定
---

## 灵活的架构

尽管许多人试图保持其代码的灵活性，但是您还需要考虑在架构，部署和供应商集成方面保持灵活性。
我们在 2019 年编写这本书。自世纪之交以来，我们已经看到以下 “最佳实践” 服务器端架构：

  - 大块的铁
  - 大铁联合会
  - 负载均衡的商品硬件集群
  - 运行应用程序的基于云的虚拟机
  - 基于云的虚拟机运行服务
  - 上面的容器化版本
  - 云支持的无服务器应用程序
  - 不可避免地，显然有些任务又回到了大块的铁板上。

继续把最新最伟大的时尚加入到这个列表中，然后敬畏地看一眼：这是一个奇迹，任何事情都能奏效。

您如何计划这种架构的波动？ 你不能。

您可以做的就是使更改变得容易。 将第三方 API 隐藏在您自己的抽象层后面。 将代码分解为组件：即使最终将它们部署在单个大型服务器上，这种方法也比采用整体应用程序并将其拆分要容易得多。（我们有很多证据可以证明这一点。）

而且，尽管这不是特别的可逆性问题，但最后一条建议是。

---
## 提示 19 不再追随时尚
---

没人知道未来会怎样，尤其是我们！ 因此，使您的代码可以滚动：在可能的情况下“继续运行”，在必要的情况下进行滚动。

## 相关内容包括

  - 话题 28 [解耦](../Chapter5/解耦.md)
  - 话题  8 [好设计的本质](../Chapter2/好设计的本质.md)
  - 话题 10 [正交性](../Chapter2/正交性.md)
  - 话题 45 [需求坑](../Chapter8/需求坑.md)
  - 话题 19 [版本控制](../Chapter3/版本控制.md)
  - 话题 50 [初学者入门套件](../Chapter9/初学者入门套件.md)

## 挑战
  - 是时候和薛定谔的猫讨论一下量子力学了。

    假设你有一只猫和一个放射性粒子在一个封闭的盒子里。这个粒子有 50% 的几率裂变成两个。如果是的话，猫会被杀死的。如果不行，猫就没事了。那么，猫是死了还是活了？根据薛定谔的说法，正确的答案是两者都是（至少在盒子保持关闭的情况下）。每次发生有两种可能结果的亚核反应，宇宙就被克隆。在一个宇宙中，这件事发生了，而在另一个宇宙中却没有发生。猫活在一个宇宙中，死在另一个宇宙中。只有当你打开盒子你才知道你在哪个宇宙里

    难怪为未来编码很难。

    但是想想代码的进化，就像一个装满了薛定谔猫的盒子：每个决定都会导致不同版本的未来。代码可以支持多少种可能的未来？哪个可能性更大？到时候支持他们有多难？

    你敢打开盒子吗？
