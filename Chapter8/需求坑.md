# 需求坑
<!-- 2020.04.23 -->

> _真正的完美不在于无须加入任何其他元素，而在于不再需要削除任何细节。_
>
> _-- 安东尼·德·圣-埃克苏佩里 《风沙星辰》 1939_

很多书和教程都把需求收集 作为项目的早期阶段。"聚集" 这个词似乎意味着一群快乐的分析家，在轻轻地演奏着《牧歌交响曲》背景乐时，寻找着散落在周围地面上的智慧碎片。"收集" 意味着这些要求已经存在，你只需要找到它们，把它们放进你的篮子里，就可以愉快地上路了。

但事实并非如此。需求很少存在于表面上。通常情况下，它们被深埋在假设、误解和政治性的层层深渊之下。更糟糕的是，它们往往根本就不存在。

## 需求神话
在软件的早期，计算机的价值（按每小时的摊销成本计算）比使用计算机的人更有价值。我们通过尝试在第一时间就把事情做对，从而节省了资金。这个过程的一部分就是要明确说明我们要让机器做什么。我们会先得到一个需求规范，然后将其转化为设计文档，再转化为流程图和伪代码，最后转化为代码。但在将其输入计算机之前，我们要花时间进行桌面检查。

这要花很多钱。这种成本意味着人们只有在知道自己想要什么的时候才会尝试自动化。而且由于早期的机器相当有限，它们所解决的问题的范围受到了限制：在你开始工作之前，实际上是有可能了解整个问题的。

但这不是真实的世界。真实的世界是混乱的、冲突的、未知的。在那个世界里，任何事物的精确规格都是罕见的，甚至是完全不可能的。

---
## 提示 75 没有人确切的知道他们到底想要什么
---

这就是我们程序员的作用所在。我们的工作就是帮助人们了解他们想要什么。事实上，这可能是我们最有价值的属性。而这一点是值得重复的。

---
## 提示 76 程序员帮助人们了解他们想要的东西
---

## 编程即治疗
让我们把找我们写软件的人称为我们的客户。

典型的客户是带着需求来找我们的。这个需求可能是战略性的，但也可能是战术性的问题：对当前问题的回应。这个需求可能是对现有系统的改变，也可能是对新系统的要求。这种需求有时会用商业术语来表达，有时也会用技术术语来表达。

新的开发人员经常犯的错误就是拿着这个需求声明去实现这个需求的解决方案。

根据我们的经验，这个最初的需求陈述并不是绝对的需求。客户可能没有意识到这一点，但这其实是一种探索的邀请。

让我们举一个简单的例子。

你为一家纸质和电子书的出版商工作。你被赋予了一个新的要求。

    所有 50 美元以上的订单都应该免运费。

停一停，想象一下自己在那个位置上的情景。你首先想到的是什么？

你很有可能会有这样的疑问。

- 50 美元是否包括税费？
- 这 50 美元是否包括当前的运费？
- 这 50 美元必须是纸质书，还是也可以包括电子书？
- 提供什么样的运输方式？优先邮递？陆运？
- 国际订单如何处理？
- 50 美元的限额今后多久会有变化？

这就是我们所做的事情。当给到一些看似简单的东西时，我们会通过寻找边缘案例并询问边缘案例来烦他们。

客户很可能已经想到了其中的一些情况，只是假设实现的时候会这样做。问这个问题只是把这些信息冲掉了。

但其他的问题很可能是客户之前没有考虑过的事情。这就是事情变得有趣的地方，也是一个好的开发者要学会外交的地方。

    你：我们想知道50美元的总费用是多少？这是否包括我们通常会收取的运费？

    客户：当然包括了。这是他们会付给我们的总价。

    你：这对我们的客户来说很好，也很容易理解。我能看出其中的吸引力。但我可以看到一些不那么肆无忌惮的客户想玩这个系统。

    客户：怎么会这样？

    你：好吧，假设他们买一本书 25 美元，然后选择隔夜运输，最贵的选项。那很可能是 30 美元左右，整个订单就会变成 55 美元。然后我们就可以免运费，他们只需要花 25 美元买一本 25 美元的书，就可以得到隔夜运费。

    (这时，有经验的开发者就停了下来。交付事实，让客户做决定，)

    客户: Ouch. 这肯定不是我的本意，我们会在这些订单上赔钱。有什么选择？

这就开始了一个探索。你的角色是解释客户说的话，并将其含义反馈给他们。这既是一个智力的过程，也是一个创造性的过程：你在用你的脚去思考，你所贡献的解决方案很可能比你或客户单独提出的方案要好。

## 需求是一个过程
在上一个例子中，开发者把需求和结果反馈给客户。这就开始了探索。在这个探索过程中，你很可能会在客户玩弄不同的解决方案时，得到更多的反馈。这就是所有需求收集的现实。

---
## 提示 77 需求是在反馈循环中学习的
---

你的工作是帮助客户了解他们所提出的要求的后果。你要做的是通过产生反馈，并让他们利用这些反馈来完善自己的想法。

在前面的例子中，反馈很容易用语言表达出来。但有时情况并非如此。而且有时候，说实话，你对这个领域的了解还不够具体。

在这种情况下，务实的程序员就会依靠 "这就是你的意思吗" 的反馈方式。我们会制作出模型和原型，然后让客户来玩。最理想的情况是，我们制作的东西足够灵活，在与客户讨论的过程中，我们可以改变它们，让我们用 "那不是我的意思" 来回应 "那么更像这样吗？"。

有时候，这些模拟图可以在一个小时左右的时间里拼凑出来。很明显，它们只是为了表达一个想法而拼凑出来的。

但事实上，我们所做的所有工作实际上都是某种形式的模拟。即使是在项目结束时，我们仍然在解释客户想要的东西。事实上，到了那个时候，我们可能会有更多的客户：QA人员、运营、营销，甚至可能还有测试组的客户。

所以，务实的程序员把所有的项目都看成是需求收集工作。这就是为什么我们更喜欢短期的迭代；那些以客户直接反馈结束的项目。这可以让我们的工作步入正轨，并确保如果我们走错了方向，就能最大限度地减少时间损失。

## 站在客户的立场上行走
有一个简单的技巧，可以让你进入客户的内心，但并不经常使用：成为客户。你是否在为服务台开发一个系统？花几天时间和一个有经验的支持人员一起监视电话。你是在自动化人工库存控制系统吗？在仓库工作一个星期。

除了让你深入了解系统的真正用途之外，你会惊讶于 "我可以在你工作的时候坐一个星期吗？"的要求有助于建立信任，并与客户建立起沟通的基础。只要记住不要妨碍到你的工作就可以了!

---
## 提示 78 与用户合作，像用户一样思考问题
---

收集反馈也是开始与客户群建立友好关系的时候，了解他们对你所建立的系统的期望和希望。更多信息，请参见话题51，[_让用户满意_](../Chapter9/让用户满意.md)。

## 需求与政策
让我们想象一下，在讨论人力资源系统的时候，客户说："只有员工的主管和人事部门可以查看该员工的记录。" 这句话真的是要求吗？也许在今天看来是这样的，但它将商业政策嵌入了绝对的声明中。

商业政策？是要求？这是一个比较细微的区别，但对于开发者来说，这将会产生深远的影响。如果需求陈述为 "只有主管和人员可以查看员工记录"，那么开发者可能最终会在每次应用访问这些数据时，都要编码一个显式测试。但是，如果声明是 "只有授权用户才能访问员工记录"，那么开发者很可能会设计并实现某种访问控制系统。当策略发生变化（而且会发生）时，只需要更新该系统的元数据。事实上，用这种方式收集需求，自然就会导致你的系统有很好的事实支持元数据。

事实上，这里有一个一般的规则：

---
## 提示 79 政策就是元数据
---

落实通例，以政策信息为例，系统需要支持的事情类型。

## 需求与现实
在1999年1月的《连线》杂志上的一篇文章中，制作人和音乐家 Brian Eno 描述了一种不可思议的技术--终极调音板。它可以做任何可以做的声音。然而，它非但没有让音乐人制作出更好的音乐，或以更快的速度或更低的成本制作出更多的唱片，反而妨碍了创作过程。

要知道为什么，你必须看看录音工程师是如何工作的。他们凭着直觉来平衡声音。多年来，他们在耳朵和指尖之间形成了一个与生俱来的反馈回路--滑动推子、旋转旋钮等等。然而，新调音台的界面并没有利用这些能力。相反，它强迫用户在键盘上打字或点击鼠标。它所提供的功能非常全面，但却以不熟悉和陌生的方式进行了包装。工程师们需要的功能有时被隐藏在晦涩难懂的名字后面，或者是通过非直观的基本设施组合来实现。

这个例子也说明了我们的信念：成功的工具要适应使用它们的人。成功的需求收集就考虑到了这一点。而这就是为什么早期的反馈，用原型或示踪弹，会让你的客户说："是的，它做了我想要的，但不是我想要的方式。"

### 文档化需求
我们相信，最好的需求文档，也许是唯一的需求文档，就是工作代码。

但这并不意味着你可以不记录你对客户需求的理解，就可以离开。这只是意味着这些文档不是一个可交付的文档：它们不是你交给客户签字的东西。相反，它们只是一个帮助指导实施过程的路标。

### 需求文档不是为客户准备的
在过去，Andy 和 Dave 都曾参与过一些项目，这些项目的要求非常详细。这些实质性的文件是在客户最初两分钟的需求解释的基础上进行了扩展，制作出了满满是图表和表格的厚厚的杰作。在实施过程中几乎没有任何含糊不清的地方。如果有了足够强大的工具，文档实际上可以成为最终的程序。

创建这些文档是一个错误，原因有两个。首先，正如我们已经讨论过的那样，客户在前期并不真正知道他们想要什么。所以，当我们把他们说的东西，扩展成几乎是一个法律文件的时候，我们就是在流沙上建造了一个无比复杂的城堡。

你可能会说："但是我们把文件拿给客户，然后他们就会签字。我们会得到反馈。" 而这就引出了这些需求说明书的第二个问题：客户从来不看这些需求说明书。

客户使用程序员的原因是，虽然客户的动机是为了解决一个高层次的、有点模糊的问题，但程序员却对所有的细节和细微之处感兴趣。而需求文档是为开发人员写的，其中包含的信息和细微之处有时让客户难以理解，经常让客户感到厌烦。

提交一份 200 页的需求文档，客户很可能会仔细阅读，以决定它是否足够重要，他们可能会阅读前几段（这就是为什么前两段总是以管理摘要为标题的原因），他们可能会翻阅剩下的内容，有时会在有一个整齐的图表时停下来。

这样做并不是让客户失望。但给他们一个大的技术文档，就像给一般的开发者一份荷马史诗的《伊利亚特》，要求他们从里面编写视频游戏的代码一样。

### 需求文件是为了做计划
所以我们不相信一刀切的、厚重到足以让人眩晕的需求文档。但是我们知道需求必须要写下来，因为团队中的开发人员需要知道他们要做什么。

这需要采取什么样的形式呢？我们偏向于那些可以装在真实（或虚拟）索引卡上的东西。这些简短的描述通常被称为用户故事。它们从该功能的用户的角度描述了应用中的一小部分应该在什么时候做的事情。

当以这种方式写出来时，这些需求可以放在一个板子上，并且可以移动，以显示状态和优先级。

你可能会认为，一张索引卡无法容纳实现应用程序的某个组件所需的信息。你的想法是对的。而这也是重点的一部分。通过保持这个需求声明的简短，你鼓励开发人员提出澄清问题。你在每一段代码的创建之前和创建过程中，都会加强客户和编码人员之间的反馈过程。

## 过度规范化
制作需求文档的另一大危险是过于具体。好的需求是抽象的。就需求而言，能准确反映业务需求的最简单的陈述是最好的。这并不意味着你可以含糊其辞--你必须把底层的语义不变性作为需求，并把具体的或当前的工作实践作为策略记录下来。

需求不是架构，也不是设计。也不是用户界面。需求就是需要。

---
## 提示 80 抽象比细节更持久
---

## 只需再来一个威化薄荷.....
许多项目的失败都归咎于范围的增加，也就是所谓的功能臃肿、蠕动壮举主义或需求蠕动。这是由话题 4 [_石汤和煮青蛙_](../Chapter1/石头汤和煮青蛙.md) 中的 "煮青蛙综合症 "的一个方面。我们可以做什么来防止需求的爬行呢？

答案（又是）是反馈。如果你和客户在迭代中不断的反馈，那么客户会亲身体验到 "只需多一个功能" 的影响。他们会看到另一张故事卡在黑板上出现，他们会帮助选择另一张卡进入下一个迭代，以腾出空间。反馈是双向的。

## 维持一个词汇表
一旦你开始讨论需求，用户和领域专家就会使用某些对他们有特定意义的术语。例如，他们可能会区分 "client" 和 "customer"。这时，在系统中随意使用这两个词都是不合适的。

创建和维护一个项目词汇表，定义项目中使用的所有特定术语和词汇。项目的所有参与者，从终端用户到支持人员，都应该使用该词汇表，以确保一致性。这意味着，词汇表需要广泛地使用--这是对在线文档的一个很好的论证（稍后会有更多的说明）。

---
## 提示 81 使用项目词汇表
---

在一个项目中，如果用户和开发者用不同的名字来指代同一个东西，或者更糟糕的是，用同一个名字来指代不同的东西，这是很难成功的。

## 相关内容包括
- 话题 7  [_沟通_](../Chapter1/沟通.md)
- 话题 23 [_契约设计_](../Chapter4/契约设计.md)
- 话题 5  [_足够好的软件_](../Chapter1/足够好的软件.md)
- 话题 46 [_解决不可能的难题_](./解决不可能的难题.md)
- 话题 42 [_基于属性的测试_](../Chapter7/基于属性的测试.md)
- 话题 13 [_原型和便签_](../Chapter2/原型和便签.md)
- 话题 11 [_可逆性_](../Chapter2/可逆性.md)
- 话题 43 [_在外部保持安全_](../Chapter7/在外部保持安全.md)
- 话题 44 [_命名_](../Chapter7/命名.md)
- 话题 51 [_让用户满意_](../Chapter9/让用户满意.md)

## 练习
### 练习 32 (尽可能回答)
以下哪项可能是真正的要求？重述那些不是，使其更有用（如果可能的话）。
1. 响应时间必须小于 500ms。
2. 模态窗口将有一个灰色背景。
3. 应用程序将被组织成若干个前端进程和一个后端服务器。
4. 如果用户在数字字段中输入非数字字符，系统将闪烁字段背景，不接受。
5. 这个嵌入式应用的代码和数据必须在 32Mb 以内。

## 挑战
- 你能用上你所编写的软件吗？能否对需求有一个很好的感觉，而不需要 "能够自己使用软件"？
- 选一个你目前需要解决的非计算机相关的问题。生成一个非计算机解决方案的需求。
